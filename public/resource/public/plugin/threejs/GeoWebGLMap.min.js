(function (w) {

    __getJSPath = function (js) {
        var scripts = document.getElementsByTagName("script");
        var path = "";
        for (var i = 0, l = scripts.length; i < l; i++) {
            var src = scripts[i].src;
            if (src.indexOf(js) != -1) {
                var ss = src.split(js);
                path = ss[0];
                break;
            }
        }
        var href = location.href;
        href = href.split("#")[0];
        href = href.split("?")[0];
        var ss = href.split("/");
        ss.length = ss.length - 1;
        href = ss.join("/");
        if (path.indexOf("https:") == -1 && path.indexOf("http:") == -1 && path.indexOf("file:") == -1 && path.indexOf("\/") != 0) {
            path = href + "/" + path;
        }
        return path;
    }

    var BASE_PATH = __getJSPath("three.js");



    // 拷贝对象
    function objCopy() {
        var target = arguments[0] || {},
            source,
            i = 1,
            length = arguments.length;

        function is(obj, type) {
            var toString = Object.prototype.toString;
            return (type === "Null" && obj === null)
                || (type === "Undefined" && obj === undefined)
                || toString.call(obj).slice(8, -1) === type;
        }

        for (; i < length; i++) {
            // Only deal with non-null/undefined values
            if ((source = arguments[i]) != null) {
                // Extend the base object
                for (var key in source) {
                    var copy = source[key];
                    if (source === copy)
                        continue; // 如window.window === window，会陷入死循环，需要处理一下
                    if (is(copy, "Object")) {
                        target[key] = arguments.callee(target[key] || {}, copy);
                    } else if (is(copy, "Array")) {
                        target[key] = arguments.callee(target[key] || [], copy);
                    } else {
                        target[key] = copy;
                    }
                }
            }
        }
        source = null;

        return target;
    }
    function RingTween(mesh){
        this.mesh = mesh;
        this.create();
    }
    RingTween.prototype={
        mesh:undefined,
        max:2,
        index:0,
        startScale:0,
        k:0,
        create:function(){
            var me =this;
            this.opacity=d3.scaleLinear().domain([0,GeoWebGLMap.RING_RADIUS*2]).range([0.9,0.3]);
            this.mesh.material.needsUpdate=true;
        },
        run:function(){
            var me =this;
            this.k+=(GeoWebGLMap.RING_RADIUS*2/GeoWebGLMap.RING_SPEED);
            var to =  {x:this.k*this.mesh._k,y:this.k*this.mesh._k,z:this.k*this.mesh._k,t:this.opacity(this.k)};
            // me.mesh.material.opacity=this.opacity(this.k);
            // me.mesh.geometry.dispose();
            // me.mesh.geometry = new THREE.RingBufferGeometry(0.0001,this.k,128);

            for ( var field in me.mesh.scale ) {
                me.mesh.scale[ field ] = parseFloat(to[field], 5);
            }

            if(this.k > GeoWebGLMap.RING_RADIUS*2){
                this.k = 0;
            }

        }
    }

    /**
     * 函数节流方法
     * @param Function fn 延时调用函数
     * @param Number delay 延迟多长时间
     * @return Function 延迟执行的方法
     */
    var Throttle = function (fn, delay) {
        var timer = null;
        var previous = null;
        return function () {
            var now = +new Date();
            if (!previous) previous = now;
            var editors = arguments;

            if (now - previous > delay) {
                fn.apply(null, editors);
                previous = now;
                clearTimeout(timer);
            } else {
                clearTimeout(timer);
                timer = setTimeout(function () {
                    fn.apply(null, editors);
                }, delay);
            }

        }
    };
    window.Throttle = Throttle;
    function GeoWebGLMap(id, config) {
        if(config){
            objCopy(this.settings, config);
        }

        this.id = '_' + (+new Date());
        this.view = d3.select(id);

    }
    GeoWebGLMap.setPixelRatio=false;
    GeoWebGLMap.RING_SPEED=20;
    GeoWebGLMap.RING_TIMEOUT=4000;
    GeoWebGLMap.RING_RADIUS=0.02;
    GeoWebGLMap.MAX_MARK_COUNT=500;
    GeoWebGLMap.HIGH_LIGHT = 0x253230//
    /**
     * 连线顶点数量
     * @type {number}
     */
    GeoWebGLMap.LINE_VERTEX_COUNT=8;
    GeoWebGLMap.CAMERA_Z=1.8;
    GeoWebGLMap.ADDMARKTIME=1;//添加点的时延
    GeoWebGLMap.prototype = {
        georadius:1,
        settings:{
            enterLocation: [116.425175, 39.909102],
            atmosphere:true,
            shape:'plane',//类型plane,sphere
            showtext: true,
            maxcount: 1,
            events:{
                onClick:function () {

                },
                onBefore:function () {

                },
                onEnd:function () {

                }
            },
            tipFormatter:function(data){
                return data.name;
            }
        },

        _markdata: [],//标记点
        _extramarkdata: [],//源
        drawTimer: undefined,
        view: null,
        __threeGeoJSON:undefined,//投影函数
        _scene: undefined,//场景
        _camera: undefined,//摄像机
        _defposition:undefined,
        _controls: undefined,//控制器
        _renderer: undefined,//渲染器
        _intersected: undefined,//相交
        _intersectedpolygon:undefined,//相交多边形
        _sourceray: new THREE.Raycaster(),//源射线
        _polygonray: new THREE.Raycaster(),//多边形射线
        _staticobj: new THREE.Object3D(),//其他
        _lineobj: new THREE.Object3D(),//线
        _tempObj: new THREE.Object3D(),//源
        _sourceObj: new THREE.Object3D(),//源
        _labelObj: new THREE.Object3D(),//tip提示组
        _polygonobj: new THREE.Object3D(),//多边形
        _highlightMaterial: new THREE.MeshBasicMaterial({color: GeoWebGLMap.HIGH_LIGHT, transparent: true, opacity: 0.8}),//高亮
        //_highlightLabelMaterial: new THREE.MeshBasicMaterial({color: 'rgba(255, 0, 12, 1)', transparent: true, opacity: 0.8}),//高亮label
        _defaultlabelmaterial:undefined,
        _defaultmaterial: undefined,//默认

        __buildToolTip: function () {
            //提示框 （注意设置提示框的绝对路径）

            var deftipCss = {
                'margin': '3px',
                'position': 'absolute',
                'visibility': 'hidden',
                'border-style': 'solid',
                'white-space': 'nowrap',
                'z-inde': '9999999',
                'transition': '0.5s cubic-bezier(0.23, 1, 0.32, 1)',
                'background-color': 'rgba(50, 50, 50, 0.7)',
                'border-width': '0px',
                'border-color': 'rgb(51, 51, 51)',
                'border-radius': '4px',
                'color': '#fff',
                'opacity': '0',
                'font-style': 'normal',
                'font-variant': 'normal',
                'font-weight': 'normal',
                'font-stretch': 'normal',
                'font-size': '14px',
                'font-family': 'sans-serif',
                'line-height': '21px',
                'padding': '5px',
                'left': '0',
                'top': '0',
            }
            this._tooltip = this.view.append('div').attr('id', this.id + '-tooltip').attr('class', 'tooltip');
            for (var k in deftipCss) {
                this._tooltip.style(k, deftipCss[k]);

            }
        },
        _showTip: function (data, point) {
            this._tooltip.style('visibility', 'visible').style('opacity', '1').style('top',
                point.y + 'px').style('left', point.x + 'px').html(this.settings.tipFormatter(data));
        },
        _hideTip: function () {
            this._tooltip.style('visibility', 'hidden').style('opacity', '0')
        },
        _markIndex:0,
        THREECacheId:0,
        _THREE_GC_COUNT:0,
        _THREE_GC:function () {
            if(GeoWebGLMap.MAX_MARK_COUNT>0){
                if(this._THREE_GC_COUNT>GeoWebGLMap.MAX_MARK_COUNT)THREE.Cache.clear,this._THREE_GC_COUNT=0;
            }else{
                if(this._THREE_GC_COUNT>50)THREE.Cache.clear,this._THREE_GC_COUNT=0;
            }

        },
        _buildThrottle:function () {
            var me =this;
            this._addmarkthrottle = Throttle(function(data){
                // if(GeoWebGLMap.MAX_MARK_COUNT>0){
                //     if(me._markdata.length>GeoWebGLMap.MAX_MARK_COUNT){
                //         if(me._markIndex>=GeoWebGLMap.MAX_MARK_COUNT) me._markIndex =150;
                //         me._markdata.splice(me._markIndex, 1);
                //         me._markIndex++;
                //     }
                // }
                me._buildMark(data);
            },GeoWebGLMap.ADDMARKTIME);


            this._removeThrottle = Throttle(function(data){

                var m = data;

                me._lineobj.remove(m.laser.line);
                m.laser.line.geometry.dispose();
                m.laser.line.remove();
                me._lineobj.remove(m.laser.point);
                m.laser.point.remove();

                me._lineobj.remove(m.targetTween.mesh);
                m.targetTween.mesh.geometry.dispose();
                m.targetTween.mesh.remove();
                if(m.sourceTween){
                    me._sourceObj.remove(m.sourceTween.mesh);
                    m.sourceTween.mesh.geometry.dispose();
                    m.sourceTween.mesh.remove();
                }
                me._THREE_GC_COUNT++;
                me._THREE_GC();
                for (var i = 0; i < me._markdata.length; i++) {
                   if(me._markdata[i]._id==data._id){
                       me._markdata.splice(i, 1);
                   }
                }
            },10);

            this._removeExtraThrottle = Throttle(function(m){
                me._lineobj.remove(m.laser.line);
                m.laser.line.geometry.dispose();
                m.laser.line.remove();
                me._lineobj.remove(m.laser.point);
                m.laser.point.remove();
                me._lineobj.remove(m.targetTween.mesh);
                m.targetTween.mesh.geometry.dispose();
                m.targetTween.mesh.remove();

                me._THREE_GC_COUNT++;
                me._THREE_GC();
            },12);

            this._removeSourceThrottle = Throttle(function(data){
                var m = data;
                me._labelObj.remove(m.label);
                m.label.geometry.dispose();
                m.label.remove();
                me._sourceObj.remove(m.sourceTween.mesh);
                m.sourceTween.mesh.geometry.dispose();
                m.sourceTween.mesh.remove();

                me._THREE_GC_COUNT++;
                me._THREE_GC();
                for (var i = 0; i < me._extramarkdata.length; i++) {
                    if(me._extramarkdata[i]._id==data._id){
                        me._extramarkdata.splice(i, 1);
                    }
                }
            },14);
        },
        ratio:function(){
            //return 16/9;
            return this.width/this.height;
        },

        __createSphereHalo:function(geometry){

            var customMaterialAtmosphere = new THREE.ShaderMaterial({
                uniforms: {
                    "c": {
                        type: "f",
                        value: 0.6
                    },
                    "p": {
                        type: "f",
                        value: 5.0
                    }
                },
                vertexShader: [
                    'varying vec3 vNormal;',
                    'void main() {',
                    'vNormal = normalize( normalMatrix * normal );',
                    'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
                    '}'
                ].join('\n'),
                fragmentShader: [
                    'uniform float c;',
                    'uniform float p;',
                    'varying vec3 vNormal;',
                    'void main() {',
                    'float intensity = pow( c - dot( vNormal, vec3( 0.0, 0.0, 1.0 ) ), p ); ',
                    'gl_FragColor = vec4( 1.0, 1.0, 1.0, 1.0 ) * intensity;',
                    '}'
                ].join('\n')
            });
            var halomesh = new THREE.Mesh(geometry, customMaterialAtmosphere);
            halomesh.scale.x = halomesh.scale.y = halomesh.scale.z = 1.3;
            halomesh.material.side = THREE.BackSide;
            return halomesh;
        },
        __drawSphere:function () {
            var me =this;
            var spherematerial=new THREE.MeshLambertMaterial({color:0x090909});
            //Create a sphere to make visualization easier.
            var geometry = new THREE.SphereBufferGeometry(this.georadius, 128, 128);

            var pattern=new THREE.TextureLoader();
            pattern.load(BASE_PATH+"/image/spark.png",function(texture){
                texture.wrapS=texture.wrapT=THREE.RepeatWrapping;
                texture.repeat.set(800,400);
                //0xFFFFFF #7b7b7b
                var basicMaterial=new THREE.MeshBasicMaterial({
                    map:texture,side: THREE.DoubleSide,color:0xFFFFFF,wireframe:false,transparent:true,opacity:1
                });

                var earth = new THREE.Group();
                earth.add(new THREE.Mesh(geometry,spherematerial));
                earth.add(new THREE.Mesh(geometry,basicMaterial));
                if(me.settings.atmosphere){
                    earth.add(me.__createSphereHalo(geometry));
                }
                earth.scale.multiplyScalar(0.99);
                earth.position.copy(new THREE.Vector3());
                me._staticobj.add(earth);
            });

        },
        build: function () {
            this.settings.events.onBefore(this);
            this._highlightMaterial = new THREE.MeshBasicMaterial({color: GeoWebGLMap.HIGH_LIGHT, transparent: true, opacity: 0.8}),//高亮
            this._drawMap();
        },
        switchShape:function (shape) {
            this.settings.shape=shape;
            this._destroy();
            this._buildControls();
            this._drawGeo();
            this._buildRotate();
            this.start();
        },
        __destroyObject3D:function(list,df){

            if(list.length==0){
                return;
            }else{
                df(list.pop());
                this.__destroyObject3D(list,df);
            }

        },
        _destroy:function(){
            var me =this;

            this.__destroyObject3D(this._staticobj.children,function (obj) {
                me._staticobj.remove(obj);
            });
            this.__destroyObject3D(this._polygonobj.children,function (obj) {
                me._polygonobj.remove(obj);
            });
            this._clearData();

            THREE.Cache.clear();
            this._markdata= [];//标记点
            this._extramarkdata= [];//源
            this._controls.destroy();
            this.stop();
            this._render();
        },
        _clearData:function(){
            var me =this;


            this.__destroyObject3D(this._labelObj.children,function (obj) {
                me._labelObj.remove(obj);
            });
            this.__destroyObject3D(this._lineobj.children,function (obj) {
                me._lineobj.remove(obj);
            });
            this.__destroyObject3D(this._tempObj.children,function (obj) {
                me._tempObj.remove(obj);
            });
            this.__destroyObject3D(this._sourceObj.children,function (obj) {
                me._sourceObj.remove(obj);
            });

            THREE.Cache.clear();
            this._markdata= [];//标记点
            this._extramarkdata= [];//源
            this._render();
        },
        _buildControls:function () {

            this._controls = new THREE.TrackballControls(this._camera,this.view.node());
            if(this.settings.shape=='plane'){
                //Enable controls
                this._controls = new THREE.TrackballControls(this._camera,this.view.node());
                this._controls.mouseButtons = { ORBIT: THREE.MOUSE.RIGHT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.LEFT };
                this._controls.rotateSpeed = 0;
                this._controls.zoomSpeed = 1.3;
                this._controls.panSpeed = 0.6;
                this._controls.enabled = true;
                this._controls.noRotate = false;
                this._controls.noZoom = false;
                this._controls.noPan = false;
                this._controls.staticMoving = false;
                //动态阻尼系数
                this._controls.dynamicDampingFactor = 0.2;
                this._controls.minDistance = 0.1;
                this._controls.maxDistance=0.8;

                this._camera.position.set(0,0,GeoWebGLMap.CAMERA_Z/10);

            }else if(this.settings.shape=='sphere'){
                //Enable controls
                this._controls.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };
                this._controls.rotateSpeed = 0.6;
                this._controls.zoomSpeed = 0.3;
                this._controls.enabled = true;
                this._controls.noRotate = false;
                this._controls.noZoom = false;
                this._controls.noPan = true;
                this._controls.staticMoving = false;
                //动态阻尼系数
                this._controls.dynamicDampingFactor = 0.2;
                this._controls.minDistance = 1;
                this._controls.maxDistance=8;
                this._camera.position.set(0,0,GeoWebGLMap.CAMERA_Z);
            }

        },
        _drawMap: function (id) {
            var me = this;
            var clientRect = this.view.node().getBoundingClientRect();
            this.view.style('position','relative');
            this.width = clientRect.width,
                this.height = clientRect.height;
            this._scene = new THREE.Scene();
            this._camera = new THREE.PerspectiveCamera(75, me.ratio(), 0.01, 200);
            this._scene.add(this._camera);
            this._camera.position.set(0,0,GeoWebGLMap.CAMERA_Z);
            this._camera.lookAt(this._scene.position);//设置视野的中心坐标
            //Enable controls
            this._buildControls();
            //New Renderer
            //var renderer = new THREE.CanvasRenderer();
            this._renderer = new THREE.WebGLRenderer({alpha: true, antialias: true});
            if(GeoWebGLMap.setPixelRatio){
                this._renderer.setPixelRatio( window.devicePixelRatio );
            }

            this._renderer.clear();
            this._renderer.setSize(this.width, this.height);
            this.view.node().appendChild(this._renderer.domElement);


            this._buildScene();
            this._buildThrottle();
            this._drawGeo();
            this._buildRotate();
            this._events();
            this.__buildToolTip();
        },
        _buildRotate:function(){
            var rotateX = 0.0002,
                rotateY = 0,
                rotateZ = 0;
            if(this.settings.shape=='plane'){

            }else if(this.settings.shape=='sphere'){
                rotateX = Math.PI*0.71,
                    rotateY = Math.PI*1,
                    rotateZ = Math.PI*-0.09;
            }
            this._lineobj.rotation.set(rotateX,rotateY,rotateZ);
            this._staticobj.rotation.set(rotateX,rotateY,rotateZ);
            this._sourceObj.rotation.set(rotateX,rotateY,rotateZ);
            this._labelObj.rotation.set(rotateX,rotateY,rotateZ);
            this._polygonobj.rotation.set(rotateX,rotateY,rotateZ);
            this._tempObj.rotation.set(rotateX,rotateY,rotateZ);
        },
        _buildScene: function () {

            this._scene.add(new THREE.AmbientLight(0x333333));
            this._scene.add(this._lineobj);
            this._scene.add(this._staticobj);
            this._scene.add(this._sourceObj);
            this._scene.add(this._labelObj);
            this._scene.add(this._polygonobj);
            this._scene.add(this._tempObj);

        },
        __getHiddenProp:function (){
            var prefixes = ['webkit','moz','ms','o'];
            if ('hidden' in document) return 'hidden';
            for (var i = 0; i < prefixes.length; i++){
                if ((prefixes[i] + 'hidden') in document)
                    return prefixes[i] + 'hidden';
            }
            return null;
        },
        __getVisibilityEvent:function () {
            var prefixes = ['webkit', 'moz', 'ms', 'o'];
            if ('visibilityState' in document) return 'visibilitychange';
            for (var i = 0; i < prefixes.length; i++) {
                if ((prefixes[i] + 'visibilityState') in document)
                    return prefixes[i] + 'visibilitychange';
            }
            return null;
        },
        __documentHidden:false,
        _events: function () {
            var me = this;

            var event = this.__getVisibilityEvent();
            if(event){
                document.addEventListener(event, function () {
                    me.__documentHidden = document[me.__getHiddenProp()];
                    me._clearData();
                },false);
            }

            this.view.on('dblclick', function () {
                me.resetGlobe();
            });
            this.view.on('mousemove', function () {
                // d3.event.stopPropagation();
                me.__onDocumentMouseMove();
            });
            this.view.on('mouseup', function () {
                // d3.event.stopPropagation();
                me.__onDocumentMouseUp();
            });
        },
        //恢复renderer初始状态
        resetGlobe:function (){
            var me =this;
            if(this.settings.shape=='plane'){
                this._camera.position.x=me._defposition.x;
                this._camera.position.y=me._defposition.y;
                me._controls.reset();
                var t=new TWEEN.Tween(this._camera.position).to({z:0},1000).start();
                t.onComplete(function(){
                    me._controls.reset();
                });
            }else if(this.settings.shape=='sphere'){
                var t=new TWEEN.Tween(this._camera.position).to({x:0,y:0,z:GeoWebGLMap.CAMERA_Z},1000).start();
                t.onComplete(function(){
                    me._controls.reset();
                });
            }
        },
        _mouseVector:new THREE.Vector3(0, 0, 0),
        _sourcemouseVector:new THREE.Vector3(0, 0, 0),
        _polygons:undefined,
        _tempLabel:undefined,
        __onDocumentMouseMove: function () {


            this._mouseVector.x =this._sourcemouseVector.x = (d3.event.clientX / this.width) * 2 - 1,
            this._mouseVector.y =this._sourcemouseVector.y = -(d3.event.clientY / this.height) * 2 + 1;

            this._sourceray.setFromCamera(this._sourcemouseVector, this._camera);
            this._polygonray.setFromCamera(this._mouseVector, this._camera);
            var intersects = this._polygonray.intersectObjects(this._polygonobj.children);
            if (intersects.length > 0) {
                if (this._intersectedpolygon != intersects[0].object) {
                    if(this._intersectedpolygon){
                        this._polygons = this.__threeGeoJSON._polygon[this._intersectedpolygon.userData.name];
                        for(var i=0;i<this._polygons.length;i++){
                            this._polygons[i].material = this._defaultmaterial;
                        }
                    }
                    this._intersectedpolygon = intersects[0].object;
                    this._defaultmaterial = this._intersectedpolygon.material;
                    this._polygons = this.__threeGeoJSON._polygon[this._intersectedpolygon.userData.name];
                    for(var i=0;i<this._polygons.length;i++){
                        this._polygons[i].material.needsUpdate = true;
                        this._polygons[i].material = this._highlightMaterial;
                    }
                }
                this._showTip(this._intersectedpolygon.userData,{x:d3.event.clientX,y:d3.event.clientY});
            } else {
                if(this._intersectedpolygon){
                    this._polygons = this.__threeGeoJSON._polygon[this._intersectedpolygon.userData.name];
                    for(var i=0;i<this._polygons.length;i++){
                        this._polygons[i].material = this._defaultmaterial;
                    }
                }
                this._intersectedpolygon = null;
                this._hideTip();
            }

            var sourceintersects = this._sourceray.intersectObjects(this._labelObj.children);

            if(sourceintersects.length>0){

                if (this._tempLabel != sourceintersects[0].object) {
                    if(this._tempLabel){
                        this._tempLabel.material.opacity=0;
                    }
                    this._tempLabel = sourceintersects[0].object;
                    this._defaultlabelmaterial = this._tempLabel.material;
                    this._tempLabel.material.needsUpdate = true;
                    this._tempLabel.material.opacity=1;
                }
            }else{
                if(this._tempLabel){
                    this._tempLabel.material.opacity=0;
                }
                this._tempLabel = null;
            }
        },


        __onDocumentMouseUp: function () {
            if(this._tempLabel){
                this.settings.events.onClick(this._tempLabel.userData);
            }
        },
        _points:[],
        _makeConnectionLineGeometry: function (origin, dest, color) {
            var geometry = new THREE.Geometry();
            //贝赛尔曲线
            var pos = 0.5;
            var ec = origin;
            var ic = dest;
            var distanceCenter = ec.clone().sub(ic).length();
            var start = origin;
            var end = dest;
            var mid = start.clone().lerp(end.clone(), pos);

            var material = new THREE.SpriteMaterial({
                map: new THREE.CanvasTexture(this._generateSpriteateSprite(color)),
                blending: THREE.AdditiveBlending
            });
            var particle = new THREE.Sprite(material);
            this._points =[];

            if(this.settings.shape=='plane'){
                mid.add(new THREE.Vector2(-0.01,0.01));
                mid.setZ(0.03)
                particle.scale.multiplyScalar(0.005);
                var distanceHalf = distanceCenter * pos;
                var vertexCountDesired = Math.floor(distanceHalf + GeoWebGLMap.LINE_VERTEX_COUNT) * 5;
                var splineCurveA = new THREE.QuadraticBezierCurve3(start, mid, end);

                this._points = splineCurveA.getPoints(vertexCountDesired);

            }else if(this.settings.shape=='sphere'){
                mid.setZ((origin.z+dest.z)/2);
                particle.scale.multiplyScalar(0.02);
                var mid=start.clone().lerp(end,pos);
                var midLength=mid.length()
                mid.normalize();
                mid.multiplyScalar(midLength+distanceCenter*pos);
                var normal=(new THREE.Vector3()).subVectors(start,end);
                normal.normalize();

                var distanceHalf = distanceCenter * pos;
                var vertexCountDesired = Math.floor(distanceHalf + GeoWebGLMap.LINE_VERTEX_COUNT) * 5;
                var midEndAnchor=mid.add(normal.multiplyScalar(-distanceHalf));
                var splineCurveA = new THREE.QuadraticBezierCurve3(start, midEndAnchor, end);
                this._points = splineCurveA.getPoints(vertexCountDesired);
            }


            var material = new THREE.LineBasicMaterial({color: color, opacity: 1, linewidth: 2});
            var curveGeometry = new THREE.Line(geometry, material);
            var L = this._points.length - 1;
            curveGeometry.geometry.vertices[0] = this._points[0];

            var a = [this._points[0]];

            var i = 1;
            while (i < L) {
                i++;
                a.push(this._points[0]);
            }
            curveGeometry.geometry.vertices = a;

            return {
                line: curveGeometry,
                points: this._points,
                len: L,
                point: particle
            };
        },
        _generateSpriteateSprite: function (color) {
            var c = d3.color(color);
            var canvas = document.createElement('canvas');
            canvas.width = 8;
            canvas.height = 8;
            var context = canvas.getContext('2d');
            var gradient = context.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width);
            gradient.addColorStop(0, c.toString());
            c.opacity = 0.4;
            gradient.addColorStop(0.2, c.toString());
            c.opacity = 0.2;
            gradient.addColorStop(0.4, c.toString());
            c.opacity = 0.1;
            gradient.addColorStop(1, c.toString());

            context.fillStyle = gradient;
            context.arc(canvas.width / 2, canvas.height / 2, canvas.width / 2, 0, 2 * Math.PI);
            context.fill();
            return canvas;
        },
        _buildLabel:function (f, d) {

            var geometry = new THREE.RingBufferGeometry(0.0001, (GeoWebGLMap.RING_RADIUS), 128);
            var material = new THREE.MeshBasicMaterial({
                color: d.color, transparent: true,side:THREE.DoubleSide,opacity:0
            });
            var dotSprite = new THREE.Mesh(geometry, material);
            dotSprite.position.x = f.x;
            dotSprite.position.y = f.y;
            if(this.settings.shape=='plane'){
                dotSprite.position.z = 0.00001;
                dotSprite.scale.multiplyScalar(0.2);
                dotSprite._k = 5;
            }else if(this.settings.shape=='sphere'){
                dotSprite.position.z = f.z+0.00001;
                dotSprite.lookAt(this.v3center);
                dotSprite._k = 15;
            }
            //
            dotSprite.userData = d;
            return dotSprite;
        },
        v3center:new THREE.Vector3(),
        _buildHalo: function (f, d) {
            // var geometry = new THREE.CircleGeometry(0.1, 128);
            var geometry = new THREE.RingBufferGeometry(0.0001, (GeoWebGLMap.RING_RADIUS), 128);
            var material = new THREE.MeshBasicMaterial({
                color: d.color, transparent: true,side:THREE.DoubleSide
            });
            var dotSprite = new THREE.Mesh(geometry, material);
            dotSprite.position.x = f.x;
            dotSprite.position.y = f.y;
            if(this.settings.shape=='plane'){
                dotSprite.position.z = 0.00001;
                dotSprite.scale.multiplyScalar(0.2);
                dotSprite._k = 5;
            }else if(this.settings.shape=='sphere'){
                dotSprite.position.z = f.z+0.00001;
                dotSprite.lookAt(this.v3center);
                dotSprite._k = 15;
            }
            //

            dotSprite.userData = d;
            return dotSprite;

        },
        __buildShaderMaterial:function(url,callback){
            var loader = new THREE.TextureLoader();
            loader.load(url, function(texture) {
                var material = new THREE.ShaderMaterial({
                    uniforms : {
                        tMatCap : {
                            type : 't',
                            value : texture
                        },
                        mixAmount : {
                            type : "f",
                            value : 0.0
                        }
                    },
                    vertexShader : [
                        'varying vec2 vN;',
                        'void main() {',
                        'vec4 p = vec4( position, 1. );',
                        'vec3 e = normalize( vec3( modelViewMatrix * p ) );',
                        'vec3 n = normalize( normalMatrix * normal );',
                        'vec3 r = reflect( e, n );',
                        'float m = 2. * length( vec3( r.xy, r.z + 1. ) );',
                        'vN = r.xy / m + .5;',
                        'gl_Position = projectionMatrix * modelViewMatrix * p;',
                        '}'
                    ].join('\n'),
                    fragmentShader : [
                        'uniform sampler2D tMatCap;',
                        'varying vec2 vN;',
                        'void main() {',
                        'vec3 base = texture2D( tMatCap, vN ).rgb;',
                        'gl_FragColor = vec4( base, 1. );',
                        '}'
                    ].join('\n'),
                    shading : THREE.SmoothShading
                });
                material.uniforms.tMatCap.value.wrapS = material.uniforms.tMatCap.value.wrapT = THREE.ClampToEdgeWrapping;
                callback(material);
            });
        },
        _drawGeo: function () {
            var me =this;

            this.__buildShaderMaterial(BASE_PATH+'/image/earth_fs.png',function (material) {

                me.__threeGeoJSON = new THREEGeoJSON({
                    renderPolygon:function (geo,geometry) {
                        return new THREE.Mesh(geometry, material);
                    },
                    drawLine:function (line) {
                        if(line){
                            me._staticobj.add(line);
                        }
                    },
                    drawPolygon:function (polygon) {
                        if(polygon){
                            me._polygonobj.add(polygon);
                        }
                    }
                });

                $.getJSON(BASE_PATH+"map.json", function (world) {
                    me.__threeGeoJSON._clearTemp();
                    me.__threeGeoJSON.drawThreeGeo(world, me.georadius, me.settings.shape, {
                        color: 'rgb(255, 14, 25)'
                    });
                    me._buildCityName();

                    if( me.settings.shape=='sphere'){
                        me.__drawSphere();
                        me._defposition = me._controls.moveTo(new THREE.Vector2(0,0));
                    }else if(me.settings.shape=='plane'){
                        me._center =  me.__threeGeoJSON.convertCoordinates(me.settings.enterLocation,me.georadius);
                        me._controls.update();
                        me._defposition = me._controls.moveTo(new THREE.Vector2(me._center.x,me._center.y));

                    }
                    me.settings.events.onEnd(me);
                });
            });
        },

        _buildCityName:function (){
            var me =this;
            var cachecanvas = document.createElement('canvas');
            //添加省份名称
            var text=[{"name":"新疆","cp":[88.19915,40.99048]},
                {"name":"西藏","cp":[88.48431,31.3656]},
                {"name":"内蒙古","cp":[110.5977,40.3408]},
                {"name":"青海","cp":[98.2402,35.4199]},
                {"name":"四川","cp":[102.9199,30.1904]},
                {"name":"黑龙江","cp":[128.1445,47.5156]},
                {"name":"甘肃","cp":[98.74603,40.18958]},
                {"name":"云南","cp":[103.8652,25.1807]},
                {"name":"广西","cp":[110.2813,23.6426]},
                {"name":"湖南","cp":[113.5332,28.3779]},
                {"name":"陕西","cp":[111.0,35.6396]},
                {"name":"广东","cp":[113.4668,22.8076]},
                {"name":"吉林","cp":[126.4746,43.5938]},
                {"name":"湖北","cp":[114.2363,31.1572]},
                {"name":"贵州","cp":[108.6113,26.9385]},
                {"name":"山东","cp":[118.7402,36.4307]},
                {"name":"江西","cp":[117.0156,28.29]},
                {"name":"河南","cp":[114.4668,33.8818]},
                {"name":"辽宁","cp":[123.3438,41.0889]},
                {"name":"山西","cp":[114.01,36.6611]},
                {"name":"安徽","cp":[118.2461,32.0361]},
                {"name":"福建","cp":[119.3008,26.9277]},
                {"name":"浙江","cp":[121.498,29.0918]},
                {"name":"江苏","cp":[121.0586,32.915]},
                {"name":"重庆","cp":[109.1539,30.1904]},
                {"name":"宁夏","cp":[107.9961,37.3096]},
                {"name":"海南","cp":[109.9512,19.2041]},
                {"name":"台湾","cp":[121.0254,23.5986]},
                {"name":"北京","cp":[117.52142,40.09115]},
                {"name":"天津","cp":[118.49,39.0]},
                {"name":"上海","cp":[122.4648,31.2891]},
                {"name":'河北',"cp":[116.4004,37.9688]},
                {"name":"香港","cp":[114.2578,22.3242]},
                {"name":"澳门","cp":[113.5547,22.1484]}];
            var l=text.length;
            while(l--){
                var p =this.__threeGeoJSON.convertCoordinates(text[l].cp,me.georadius)
                text[l].pos = new THREE.Vector3(p.x,p.y,p.z);
                me._staticobj.add( me.__makeTextSprite(text[l],cachecanvas.cloneNode()) );
            }
        },
        //生成canvas文字
        __makeTextSprite:function (data, canvas){
            var me =this;
            var context = canvas.getContext('2d');
            context.clearRect(0,0,100,100);
            context.font = "normal normal bold 26px Arial";
            var maxTextLen=0;
            var metrics = context.measureText( data.name );
            maxTextLen = metrics.width;

            canvas.width=maxTextLen;
            canvas.height=26+10;
            context.fillStyle = "rgba(255,255,255,1)";
            context.fillText(data.name, 0, 26);


            var texture = new THREE.Texture(canvas)
            texture.minFilter = THREE.NearestFilter;
            texture.needsUpdate = true;
            var spriteMaterial = new THREE.SpriteMaterial({ map: texture} );
            var mesh = new THREE.Sprite( spriteMaterial );
            mesh.scale.set(canvas.width,canvas.height,1);

            if(this.settings.shape=='plane'){
                mesh.position.set(data.pos.x,data.pos.y,data.pos.z+0.01);;
                mesh.scale.multiplyScalar(0.0015/3);
            }else if(this.settings.shape=='sphere'){
                mesh.position.set(data.pos.x-0.015,data.pos.y+0.005,data.pos.z+0.01);
                mesh.scale.multiplyScalar(0.0015);
            }

            return mesh;
        },
        __laser:undefined,
        __extramark:undefined,
        __mark:undefined,
        __marktween:function (mark,callback) {
            mark.sourceTween.run();
            mark.targetTween.run();
            this.__laser = mark.laser;
            if(mark.index<=this.__laser.len){
                this.__laser.line.geometry.vertices[mark.index]=this.__laser.points[mark.index];
                for(var j=mark.index;j<=this.__laser.len;j++){
                    this.__laser.line.geometry.vertices[j]=this.__laser.points[mark.index];
                    this.__laser.point.position.x =this.__laser.points[mark.index].x;
                    this.__laser.point.position.y =this.__laser.points[mark.index].y;
                    this.__laser.point.position.z =this.__laser.points[mark.index].z;
                }
                this.__laser.line.geometry.verticesNeedUpdate=true;
            }else{
                if(mark.count>(this.settings.maxcount-1)){
                    this.__laser=null;
                    if(callback) callback(mark);


                }else{
                    mark.count++;
                    mark.index=1;
                }
            }
            mark.index+=1;
        },
        _render:function () {
            var me =this;

            for (var i = 0; i < this._extramarkdata.length; i++) {
                this.__extramark= this._extramarkdata[i];
                if((+new Date()) - this.__extramark.time<GeoWebGLMap.RING_TIMEOUT){
                    // this.__extramark.sourceTween.run();
                    this.__marktween(this._extramarkdata[i],function (mark) {
                        me._removeExtraThrottle(mark);
                    });
                }else{
                    this._removeSourceThrottle(this.__extramark);
                }


            }
            for (var i = 0; i < this._markdata.length; i++) {
                this.__marktween(this._markdata[i],function (mark) {
                    me._removeThrottle(mark);
                });
            }

            this._controls.update();
            this._renderer.render(this._scene, this._camera);
            TWEEN.update();
        },
        addMark:function (data, important) {
            if(this._markIndex>Math.pow(2,20)){
                this._markIndex=0;
            }
            data['_id'] = this._markIndex++;
            if(this.__documentHidden==false){
                if (important) {
                    this._buildMark(data)
                } else {
                    this._addmarkthrottle(data);
                }
            }

        },
        __label:undefined,
        __sourceXY:undefined,
        __targetXY:undefined,
        __sourceHalo:undefined,
        __targetHalo:undefined,
        __laser:undefined,
        _buildMark: function (d) {
            if(!this.__threeGeoJSON||!this.__threeGeoJSON.convertCoordinates){
                return;
            }
            this.__sourceXY = this.__threeGeoJSON.convertCoordinates(d.from.location,this.georadius),
            this.__targetXY= this.__threeGeoJSON.convertCoordinates(d.to.location,this.georadius),
            this.__sourceHalo=this._buildHalo( this.__sourceXY,d),
            this.__targetHalo=this._buildHalo(this.__targetXY,d),
            this.__laser=this._makeConnectionLineGeometry(this.__sourceHalo.position,this.__targetHalo.position,d.color);

            if(d.status==1){
                this.__label = this._buildLabel(this.__sourceXY,d);
                this._labelObj.add(this.__label),
                this._extramarkdata.push({
                    time:+(new Date()),
                    _id:d._id,
                    index:1,
                    count:1,
                    label:this.__label,
                    sourceHalo:this.__sourceHalo,
                    targetHalo:this.__targetHalo,
                    targetTween:new RingTween(this.__targetHalo),
                    sourceTween:new RingTween(this.__sourceHalo),
                    laser:this.__laser
                });
            }else{
                this._markdata.push({
                    _id:d._id,
                    index:1,
                    count:1,
                    sourceHalo:this.__sourceHalo,
                    targetHalo:this.__targetHalo,
                    targetTween:new RingTween(this.__targetHalo),
                    sourceTween:new RingTween(this.__sourceHalo),
                    laser:this.__laser
                });
            }
            this._sourceObj.add(this.__sourceHalo)
            this._lineobj.add(this.__targetHalo);
            this._lineobj.add(this.__laser.line);
            this._lineobj.add(this.__laser.point);

            this.__sourceXY=undefined,
            this.__targetXY=undefined,
            this.__label = undefined,
            this.__sourceHalo=undefined,
            this.__targetHalo=undefined,
            this.__laser=undefined;


        },
        start: function (callback) {
            var me = this;
            this.drawTimer = d3.timer(function () {
                me._render();
            });
            if (callback) {
                callback();
            }
        },
        stop: function () {
            if (this.drawTimer) {
                this.drawTimer.stop();
            }
        }
    }

    w.GeoWebGLMap = GeoWebGLMap;

})(window);
